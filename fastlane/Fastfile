# frozen_string_literal: true

# Leka - iOS Monorepo
# Copyright APF France handicap
# SPDX-License-Identifier: Apache-2.0

# auto update fastlane
# update_fastlane

fastlane_require 'json'
fastlane_require 'open3'

default_platform(:ios)

ROOT_DIR = File.expand_path('..', Dir.pwd).to_s.freeze
SIGNING_DIR = "#{ROOT_DIR}/Tuist/Signing"

RELEASE_BUNDLE_IDS = [
  'io.leka.apf.app.LekaApp',
  'io.leka.apf.app.LekaUpdater'
].freeze

DEVELOPMENT_WILDCARD_BUNDLE_ID = 'io.leka.apf.*'

platform :ios do
  desc "Placeholder lane to make sure fastlane's working"
  lane :helloworld do
    UI.important "Hello, Fastlane! (from #{Dir.pwd}, root: #{ROOT_DIR}, signing: #{SIGNING_DIR})"
  end

  desc 'Copy certificates for tuist'
  lane :copy_certificates do |options|
    UI.important 'Delete previous provisioning profiles'
    system('rm', '-rf', "#{SIGNING_DIR}/{*.mobileprovision,*.p12*,*.cer*}")

    UI.important 'Create development provisioning profile'
    UI.message 'Generate json graph'

    Dir.chdir('..') do
      system('tuist', 'generate', '-n')
      system(
        'tuist graph ' \
        '--format json ' \
        '--skip-test-targets --skip-external-dependencies ' \
        "--output-path #{SIGNING_DIR}/raw"
      )
    end

    UI.message 'Parse json graph'
    json = File.read("#{SIGNING_DIR}/raw/graph.json")
    graph = JSON.parse(json)
    all_apps = graph['projects'].values.flat_map do |project|
      project['targets'].filter_map do |target|
        target['name'] if target['product'] == 'app' || target['product'] == 'unit_tests'
      end
    end

    UI.message 'Copy wildcard provisioning profile for each app'
    all_apps.each do |app|
      UI.message "App: #{app} --> Bundle ID: io.leka.apf.*"
      system(
        'cp -f ' \
        "#{SIGNING_DIR}/raw/dev/Development_io.leka.apf.*.mobileprovision " \
        "#{SIGNING_DIR}/#{app}.Debug.mobileprovision"
      )
    end

    UI.important 'Copy development .cer & .p12 files'
    dev_certs = Dir.entries("#{SIGNING_DIR}/raw/dev").select { |f| f.end_with?('cer') || f.end_with?('p12') }
    dev_certs.each do |cert|
      system("cp -f #{SIGNING_DIR}/raw/dev/#{cert} #{SIGNING_DIR}/#{cert}")
    end

    if options[:release]
      UI.important 'Create release provisioning profile'
      release_profiles = Dir.entries("#{SIGNING_DIR}/raw/release").select { |f| f.end_with?('mobileprovision') }
      RELEASE_BUNDLE_IDS.each do |id|
        name = id.delete_prefix('io.leka.apf.app.')
        UI.message "App: #{name} --> Bundle ID: #{id}"
        release_profiles.select { |profile| profile.include?(name) }.map do |profile|
          UI.message "App: #{name} --> Profile: #{profile}"
          if profile.include?('AppStore_')
            system("cp -f #{SIGNING_DIR}/raw/release/#{profile} #{SIGNING_DIR}/#{name}.Release.mobileprovision")
          end
        end
      end

      UI.important 'Copy release .cer & .p12 files'
      release_certs = Dir.entries("#{SIGNING_DIR}/raw/release").select do |f|
        f.end_with?('cer') || f.end_with?('p12')
      end
      release_certs.each do |cert|
        system("cp -f #{SIGNING_DIR}/raw/release/#{cert} #{SIGNING_DIR}/#{cert}")
      end
    end

    UI.message 'List newly created certificates and profiles'
    system("ls -la #{SIGNING_DIR}")
  end

  desc 'Sync certificates'
  lane :sync_certificates do |options|
    UI.important 'Delete local provisioning profiles'
    system("rm -rf #{SIGNING_DIR}")

    create_keychain(
      name: 'io.leka.fastlane.keychain',
      timeout: 0,
      unlock: true,
      password: ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil)
    )

    match(
      type: 'development',
      app_identifier: DEVELOPMENT_WILDCARD_BUNDLE_ID,
      readonly: true,
      output_path: "#{SIGNING_DIR}/raw/dev",
      keychain_name: 'io.leka.fastlane.keychain'
    )

    if options[:release]
      match(
        type: 'appstore',
        app_identifier: RELEASE_BUNDLE_IDS,
        readonly: true,
        output_path: "#{SIGNING_DIR}/raw/release",
        keychain_name: 'io.leka.fastlane.keychain'
      )
    end

    copy_certificates options
  end

  desc 'Create certificates'
  lane :create_certificates do |options|
    create_keychain(
      name: 'io.leka.fastlane.keychain',
      timeout: 0,
      unlock: true
    )

    match(
      type: 'development',
      app_identifier: DEVELOPMENT_WILDCARD_BUNDLE_ID,
      force_for_new_devices: true,
      keychain_name: 'io.leka.fastlane.keychain'
    )

    if options[:release]
      match(
        type: 'appstore',
        app_identifier: RELEASE_BUNDLE_IDS,
        keychain_name: 'io.leka.fastlane.keychain'
      )
    end
  end

  desc 'Submit new internal beta app'
  lane :beta_internal do |options|
    UI.user_error! 'A target must be specified, for example: LekaApp, LekaUpdater, etc.' if options[:targets].nil?

    apps = []

    UI.header 'Step: Set targets to build'
    if options[:targets] == 'all'
      apps = RELEASE_BUNDLE_IDS.map { |app| File.extname(app.to_s).delete('.') }
      UI.important 'All targets will be built:'
    else
      apps += options[:targets].split(',')
      UI.important 'The following targets will be built:'
    end
    UI.important apps.to_s

    build_date = Time.new.strftime('%Y_%m_%d')

    apps.each do |app|
      UI.header "Step: Generate, build & upload target: #{app}"
      Dir.chdir('..') do
        ENV['TUIST_TURN_OFF_LINTERS'] = 'TRUE'
        ENV['TUIST_DEVELOPER_MODE'] = 'TRUE'
        ENV['TUIST_TESTFLIGHT_BUILD'] = 'TRUE'
        ENV['TUIST_PRODUCTION_BUILD'] = 'FALSE'
        system('tuist', 'generate', '-n', app.to_s)
      end

      app_id = "io.leka.apf.app.#{app}"
      app_xcodeproj = "#{ROOT_DIR}/Apps/#{app}/#{app}.xcodeproj"

      begin
        if ENV['CI']
          app_store_connect_api_key(
            key_id: ENV.fetch('APP_STORE_CONNECT_API_KEY_ID', nil),
            issuer_id: ENV.fetch('APP_STORE_CONNECT_ISSUER_ID', nil),
            key_content: ENV.fetch('APP_STORE_CONNECT_API_KEY_CONTENT', nil)
          )

          unlock_keychain(
            path: 'io.leka.fastlane.keychain',
            password: ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil)
          )

          UI.header 'Step: keychain security set-key-partition-list'
          system('security', 'set-key-partition-list', '-S', 'apple-tool:,apple:', '-s', '-k',
                 ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil), 'io.leka.fastlane.keychain')
        end

        latest_build_number = latest_testflight_build_number(app_identifier: app_id.to_s).to_s
        next_build_number_major = latest_build_number.split('.').first.to_i + 1
        pr_number = ENV.fetch('PR_NUMBER', `gh pr view --json number -q .number`.strip)
        last_commit_sha_to_int = last_git_commit[:abbreviated_commit_hash].to_i(16)

        next_build_number = "#{next_build_number_major}.#{pr_number or '000'}.#{last_commit_sha_to_int}".slice(0, 18)
        version_number = get_version_number(xcodeproj: app_xcodeproj.to_s)

        UI.important "App: #{app} / Version number: #{version_number} / Build number: #{next_build_number}"

        testflight_changelog = generate_changelogs(
          target: app,
          version_number: version_number,
          latest_build_number: latest_build_number,
          next_build_number: next_build_number,
          pr_number: pr_number
        )

        increment_build_number(
          build_number: next_build_number,
          xcodeproj: app_xcodeproj.to_s
        )

        build_app(
          workspace: 'ios-monorepo.xcworkspace',
          scheme: app,
          output_directory: './.build',
          output_name: "#{build_date}-#{app}-v#{version_number}-#{next_build_number}"
        )

        upload_to_testflight(
          app_identifier: app_id.to_s,
          skip_waiting_for_build_processing: true,
          distribute_external: false,
          groups: %w[LekaTeam ClubExpert],
          changelog: testflight_changelog
        )
      ensure
        next unless ENV['CI']

        delete_keychain(
          name: 'io.leka.fastlane.keychain'
        )
      end
    end
  end

  desc 'Release new app version to App Store Connect'
  lane :release do |options|
    UI.user_error! 'A target must be specified, for example: LekaApp, LekaUpdater, etc.' if options[:target].nil?
    UI.user_error! 'Only one app can be released at a time' if options[:target].split(',').count > 1

    app = options[:target].split(',').first

    UI.header 'Step: Set target to build'
    UI.important "The following targets will be built: #{app}"

    build_date = Time.new.strftime('%Y_%m_%d')

    UI.header "Step: Generate, build & upload target: #{app}"
    Dir.chdir('..') do
      ENV['TUIST_TURN_OFF_LINTERS'] = 'TRUE'
      ENV['TUIST_DEVELOPER_MODE'] = 'FALSE'
      ENV['TUIST_TESTFLIGHT_BUILD'] = 'FALSE'
      ENV['TUIST_PRODUCTION_BUILD'] = 'TRUE'
      system('tuist', 'generate', '-n', app.to_s)
    end

    app_id = "io.leka.apf.app.#{app}"
    app_xcodeproj = "#{ROOT_DIR}/Apps/#{app}/#{app}.xcodeproj"

    begin
      if ENV['CI']
        app_store_connect_api_key(
          key_id: ENV.fetch('APP_STORE_CONNECT_API_KEY_ID_RELEASE_APP_STORE', nil),
          issuer_id: ENV.fetch('APP_STORE_CONNECT_ISSUER_ID', nil),
          key_content: ENV.fetch('APP_STORE_CONNECT_API_KEY_CONTENT_RELEASE_APP_STORE', nil)
        )

        unlock_keychain(
          path: 'io.leka.fastlane.keychain',
          password: ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil)
        )

        UI.header 'Step: keychain security set-key-partition-list'
        system('security', 'set-key-partition-list', '-S', 'apple-tool:,apple:', '-s', '-k',
               ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil), 'io.leka.fastlane.keychain')
      end

      latest_build_number = latest_testflight_build_number(app_identifier: app_id.to_s).to_s
      next_build_number_major = latest_build_number.split('.').first.to_i + 1
      pr_number = ENV.fetch('PR_NUMBER', `gh pr view --json number -q .number`.strip)
      last_commit_sha_to_int = last_git_commit[:abbreviated_commit_hash].to_i(16)

      next_build_number = "#{next_build_number_major}.#{pr_number or '000'}.#{last_commit_sha_to_int}".slice(0, 18)
      version_number = get_version_number(xcodeproj: app_xcodeproj.to_s)

      UI.important "App: #{app} / Version number: #{version_number} / Build number: #{next_build_number}"
      UI.important "Metadata path: #{ROOT_DIR}/fastlane/release/#{app}/metadata"

      # capture_screenshots # ? not working yet

      increment_build_number(
        build_number: next_build_number,
        xcodeproj: app_xcodeproj.to_s
      )

      build_app(
        workspace: 'ios-monorepo.xcworkspace',
        scheme: app,
        output_directory: './.build',
        output_name: "#{build_date}-#{app}-v#{version_number}-#{next_build_number}"
      )

      upload_to_app_store(
        force: true,
        app_identifier: app_id.to_s,
        metadata_path: "#{ROOT_DIR}/fastlane/release/#{app}/metadata",
        screenshots_path: "#{ROOT_DIR}/fastlane/release/#{app}/screenshots",
        reject_if_possible: true,
        app_rating_config_path: "#{ROOT_DIR}/fastlane/release/#{app}/metadata/app_rating_config.json",
        submission_information: {
          export_compliance_uses_encryption: false,
          add_id_info_uses_idfa: false,
          content_rights_contains_third_party_content: true,
          content_rights_has_rights: true
        },
        run_precheck_before_submit: true,
        precheck_include_in_app_purchases: false
      )
    ensure
      next unless ENV['CI']

      delete_keychain(
        name: 'io.leka.fastlane.keychain'
      )
    end
  end

  desc 'Generate changelogs for TestFlight, Github and Slack'
  lane :generate_changelogs do |options|
    UI.important options

    app_name = options[:target].to_s
    version_number = options[:version_number].to_s
    latest_build_number = options[:latest_build_number].to_s
    next_build_number = options[:next_build_number].to_s

    pr_number = options[:pr_number]

    commit_sha_pr_branch_head = last_git_commit[:abbreviated_commit_hash]
    commit_sha_latest_test_flight_build = latest_build_number.split('.').last.to_i.to_s(16).rjust(8, '0')

    UI.message "commit_sha_pr_branch_head: #{commit_sha_pr_branch_head}"
    UI.message "commit_sha_latest_test_flight_build: #{commit_sha_latest_test_flight_build}"

    git_log_to_notes_script = "#{ROOT_DIR}/Tools/Scripts/git_log_to_notes.py"

    git_log_main_pr_with_emojis, stderr_git_log_main_pr_with_emojis, status_git_log_main_pr_with_emojis =
      Open3.capture3(
        'python3',
        git_log_to_notes_script,
        '-f', 'main',
        '-l', commit_sha_pr_branch_head.to_s
      )

    git_log_latest_build_pr_branch_with_emojis, _, status_git_log_latest_build_pr_branch_with_emojis =
      Open3.capture3(
        'python3',
        git_log_to_notes_script,
        '-f', commit_sha_latest_test_flight_build.to_s,
        '-l', commit_sha_pr_branch_head.to_s
      )

    git_log_main_pr_no_emojis, stderr_git_log_main_pr_no_emojis, status_git_log_main_pr_no_emojis =
      Open3.capture3(
        'python3',
        git_log_to_notes_script,
        '-r',
        '-f', 'main',
        '-l', commit_sha_pr_branch_head.to_s
      )

    git_log_latest_build_pr_branch_no_emojis, _, status_git_log_latest_build_pr_branch_no_emojis =
      Open3.capture3(
        'python3',
        git_log_to_notes_script,
        '-r',
        '-f', commit_sha_latest_test_flight_build.to_s,
        '-l', commit_sha_pr_branch_head.to_s
      )

    if status_git_log_main_pr_with_emojis.success? && status_git_log_main_pr_no_emojis.success?
      UI.message 'Creating CHANGELOG_FOR_SLACK'

      CHANGELOG_FOR_SLACK = <<~EOF_CHANGELOG_FOR_SLACK
        :test_tube: *New TestFlight Build - #{app_name}* :airplane:

        New version of #{app_name} is available for testing on TestFlight. Please check the changelog and install the app on your device. :rocket:

        *App*: #{app_name}
        *Version*: #{version_number}
        *Build*: #{next_build_number} (#{commit_sha_pr_branch_head})
        *PR*: #{pr_number ? "https://github.com/leka/ios-monorepo/pull/#{pr_number}" : 'n/a'}

        *Changes compared to `main`*:

        #{git_log_main_pr_with_emojis.rstrip.empty? ? '_Could not fetch the changes compared to `main`._' : git_log_main_pr_with_emojis.rstrip}

        *Changes compared to the last TestFlight build*:

        #{status_git_log_latest_build_pr_branch_with_emojis.success? ? git_log_latest_build_pr_branch_with_emojis : '_Could not fetch the changes compared to the last TestFlight build. Commit may have been overwritten by force push._'}

      EOF_CHANGELOG_FOR_SLACK

      UI.message "CHANGELOG_FOR_SLACK:\n#{CHANGELOG_FOR_SLACK}"

      UI.message 'Creating CHANGELOG_FOR_GITHUB'

      CHANGELOG_FOR_GITHUB = <<~EOF_CHANGELOG_FOR_GITHUB
        ## :test_tube: New TestFlight Build - #{app_name} :airplane:

        New version of #{app_name} is available for testing on TestFlight. Please check the changelog and install the app on your device. :rocket:

        **App**: #{app_name}
        **Version**: #{version_number}
        **Build**: #{next_build_number} (#{commit_sha_pr_branch_head})
        **PR**: #{pr_number ? "https://github.com/leka/ios-monorepo/pull/#{pr_number}" : 'n/a'}

        **Changes compared to `main`**:

        #{git_log_main_pr_with_emojis.rstrip.empty? ? '*Could not fetch the changes compared to `main`.*' : git_log_main_pr_with_emojis.rstrip}

        **Changes compared to the last TestFlight build**:

        #{status_git_log_latest_build_pr_branch_with_emojis.success? ? git_log_latest_build_pr_branch_with_emojis : '*Could not fetch the changes compared to the last TestFlight build. Commit may have been overwritten by force push.*'}

      EOF_CHANGELOG_FOR_GITHUB

      UI.message "CHANGELOG_FOR_GITHUB:\n#{CHANGELOG_FOR_GITHUB}"

      UI.message 'Creating CHANGELOG_FOR_TEST_FLIGHT'

      CHANGELOG_FOR_TEST_FLIGHT = <<~EOF_CHANGELOG_FOR_TEST_FLIGHT
        Version: #{version_number}
        Build: #{next_build_number} (#{commit_sha_pr_branch_head})
        PR: #{pr_number ? "https://github.com/leka/ios-monorepo/pull/#{pr_number}" : 'n/a'}

        Changes compared to main:

        #{git_log_main_pr_no_emojis.rstrip.empty? ? 'Could not fetch the changes compared to `main`.' : git_log_main_pr_no_emojis.rstrip}

        Changes compared to the last TestFlight build:

        #{status_git_log_latest_build_pr_branch_no_emojis.success? ? git_log_latest_build_pr_branch_no_emojis : 'Could not fetch the changes compared to the last TestFlight build. Commit may have been overwritten by force push.'}

      EOF_CHANGELOG_FOR_TEST_FLIGHT

      UI.message "CHANGELOG_FOR_TEST_FLIGHT:\n#{CHANGELOG_FOR_TEST_FLIGHT}"
    else
      UI.error 'Could not fetch the changes'
      UI.error stderr_git_log_main_pr_with_emojis
      UI.error stderr_git_log_main_pr_no_emojis
    end

    if ENV['CI']
      File.write(
        ENV.fetch('GITHUB_ENV', nil).to_s,
        "CHANGELOG_FOR_SLACK<<EOF_CHANGELOG_FOR_SLACK\n" \
        "#{CHANGELOG_FOR_SLACK}\n" \
        "EOF_CHANGELOG_FOR_SLACK\n\n",
        mode: 'a'
      )
      File.write(
        ENV.fetch('GITHUB_ENV', nil).to_s,
        "CHANGELOG_FOR_GITHUB<<EOF_CHANGELOG_FOR_GITHUB\n" \
        "#{CHANGELOG_FOR_GITHUB}\n" \
        "EOF_CHANGELOG_FOR_GITHUB\n\n",
        mode: 'a'
      )
      File.write(
        ENV.fetch('GITHUB_ENV', nil).to_s,
        "CHANGELOG_FOR_TEST_FLIGHT<<EOF_CHANGELOG_FOR_TEST_FLIGHT\n" \
        "#{CHANGELOG_FOR_TEST_FLIGHT}\n" \
        "EOF_CHANGELOG_FOR_TEST_FLIGHT\n\n",
        mode: 'a'
      )
    end

    CHANGELOG_FOR_TEST_FLIGHT
  end
end
