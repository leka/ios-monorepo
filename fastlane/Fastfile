# frozen_string_literal: true

# Leka - iOS Monorepo
# Copyright APF France handicap
# SPDX-License-Identifier: Apache-2.0

# auto update fastlane
# update_fastlane

fastlane_require 'json'
fastlane_require 'open3'

default_platform(:ios)

# MARK: - Configuration Constants

# Root directory of the project (parent of fastlane directory)
ROOT_DIR = File.expand_path('..', Dir.pwd).to_s.freeze

# Git reference used as base for changelog generation
# Set via BASE_REF environment variable, defaults to 'develop' 
GIT_BASE_REF = ENV.fetch('BASE_REF', 'develop')

# Bundle IDs for production apps that can be released to App Store
RELEASE_BUNDLE_IDS = [
  'io.leka.apf.app.LekaApp',        # Main Leka App for end users
  'io.leka.apf.app.LekaApp.beta',   # Beta version for TestFlight
  'io.leka.apf.app.LekaUpdater'     # Leka robot updater app
].freeze

# Wildcard bundle ID pattern for development certificates
# Covers all Leka apps during development
DEVELOPMENT_WILDCARD_BUNDLE_ID = 'io.leka.apf.*'

# MARK: - Environment Variables Documentation
#
# The following environment variables are used by fastlane lanes:
#
# CI Configuration:
# - CI: Set to 'true' when running in CI environment
# - FASTLANE_KEYCHAIN_PASSWORD: Password for the fastlane keychain
# - FASTLANE_SKIP_UPDATE_CHECK: Set to '1' to skip fastlane update checks
#
# App Store Connect API:
# - APP_STORE_CONNECT_API_KEY_ID: Key ID for App Store Connect API
# - APP_STORE_CONNECT_ISSUER_ID: Issuer ID for App Store Connect API  
# - APP_STORE_CONNECT_API_KEY_CONTENT: Private key content for API authentication
# - APP_STORE_CONNECT_API_KEY_ID_RELEASE_APP_STORE: Separate key ID for release uploads
# - APP_STORE_CONNECT_API_KEY_CONTENT_RELEASE_APP_STORE: Separate key content for releases
#
# Code Signing (Match):
# - MATCH_PASSWORD: Password for the certificates repository
# - MATCH_GIT_BASIC_AUTHORIZATION: Basic auth token for accessing certificates repo
#
# Pull Request Information:
# - PR_NUMBER: Pull request number (set by GitHub Actions)
# - BASE_REF: Base branch for comparison (defaults to 'develop')
#
# Tuist Configuration:
# Various TUIST_* environment variables are set programmatically to configure
# the build system behavior for different contexts (development, beta, production)

platform :ios do
  # MARK: - Helper Functions
  # These functions extract common functionality used across multiple lanes
  # to reduce code duplication and improve maintainability

  private_lane :setup_keychain do
    """
    Creates and configures the temporary keychain used for code signing.
    This keychain is automatically cleaned up in CI environments.
    """
    create_keychain(
      name: 'io.leka.fastlane.keychain',
      timeout: 0,                    # Never timeout
      unlock: true,                  # Keep keychain unlocked
      password: ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil)
    )
  end

  private_lane :cleanup_keychain do
    """
    Removes the temporary keychain in CI environments.
    This prevents keychain accumulation and potential security issues.
    """
    return unless ENV['CI']
    
    delete_keychain(name: 'io.leka.fastlane.keychain')
  end

  private_lane :detect_pr_number do
    """
    Determines the pull request number for changelog context.
    Returns PR number from environment or GitHub CLI, or 'NO_PR' if none found.
    """
    if ENV['PR_NUMBER'] && !ENV['PR_NUMBER'].empty?
      ENV['PR_NUMBER']
    else
      `gh pr view --json number -q .number`.strip.tap do |output|
        output.replace('NO_PR') if output.empty?
      end
    end
  end

  private_lane :configure_tuist_environment do |options|
    """
    Sets up Tuist environment variables for project generation.
    
    Parameters:
    - build_type: 'beta' or 'release' to configure appropriate settings
    - app_bundle_id: Bundle ID for match configuration
    """
    build_type = options[:build_type]
    app_bundle_id = options[:app_bundle_id]
    
    # Common settings for all builds
    ENV['TUIST_TURN_OFF_LINTERS'] = 'TRUE'
    ENV['TUIST_GENERATE_MODULES_AS_FRAMEWORKS_FOR_DEBUG'] = 'FALSE'
    ENV['TUIST_GENERATE_L10N_SCHEMES'] = 'FALSE'
    ENV['TUIST_GENERATE_EXAMPLE_TARGETS'] = 'FALSE'
    ENV['TUIST_FASTLANE_BUILD'] = 'TRUE'
    ENV['TUIST_FASTLANE_MATCH_APP_BUNDLE_ID'] = app_bundle_id.to_s
    
    # Build-type specific settings
    if build_type == 'beta'
      ENV['TUIST_DEVELOPER_MODE'] = 'TRUE'
      ENV['TUIST_TESTFLIGHT_BUILD'] = 'TRUE'
      ENV['TUIST_PRODUCTION_BUILD'] = 'FALSE'
    elsif build_type == 'release'
      ENV['TUIST_DEVELOPER_MODE'] = 'FALSE'
      ENV['TUIST_TESTFLIGHT_BUILD'] = 'FALSE'
      ENV['TUIST_PRODUCTION_BUILD'] = 'TRUE'
    else
      UI.user_error! "Invalid build_type: #{build_type}. Must be 'beta' or 'release'"
    end
  end

  private_lane :setup_app_store_connect_auth do |options|
    """
    Configures App Store Connect API authentication for uploads.
    Uses different credentials for beta vs release for enhanced security.
    
    Parameters:
    - auth_type: 'beta' or 'release' to select appropriate credentials
    """
    return unless ENV['CI']
    
    auth_type = options[:auth_type]
    
    if auth_type == 'beta'
      app_store_connect_api_key(
        key_id: ENV.fetch('APP_STORE_CONNECT_API_KEY_ID', nil),
        issuer_id: ENV.fetch('APP_STORE_CONNECT_ISSUER_ID', nil),
        key_content: ENV.fetch('APP_STORE_CONNECT_API_KEY_CONTENT', nil)
      )
    elsif auth_type == 'release'
      app_store_connect_api_key(
        key_id: ENV.fetch('APP_STORE_CONNECT_API_KEY_ID_RELEASE_APP_STORE', nil),
        issuer_id: ENV.fetch('APP_STORE_CONNECT_ISSUER_ID', nil),
        key_content: ENV.fetch('APP_STORE_CONNECT_API_KEY_CONTENT_RELEASE_APP_STORE', nil)
      )
    else
      UI.user_error! "Invalid auth_type: #{auth_type}. Must be 'beta' or 'release'"
    end

    # Unlock keychain and set partition list for code signing
    unlock_keychain(
      path: 'io.leka.fastlane.keychain',
      password: ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil)
    )

    UI.header 'Step: keychain security set-key-partition-list'
    system('security', 'set-key-partition-list', '-S', 'apple-tool:,apple:', '-s', '-k',
           ENV.fetch('FASTLANE_KEYCHAIN_PASSWORD', nil), 'io.leka.fastlane.keychain')
  end

  private_lane :validate_build_environment do
    """
    Validates that all required environment variables are present for CI builds.
    Provides clear error messages for missing configuration.
    """
    return unless ENV['CI']
    
    required_vars = [
      'FASTLANE_KEYCHAIN_PASSWORD',
      'MATCH_PASSWORD', 
      'MATCH_GIT_BASIC_AUTHORIZATION',
      'APP_STORE_CONNECT_ISSUER_ID'
    ]
    
    missing_vars = required_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    
    unless missing_vars.empty?
      UI.user_error! "Missing required environment variables: #{missing_vars.join(', ')}"
    end
  end

  private_lane :validate_targets do |targets_string|
    """
    Validates target parameter and returns array of valid targets.
    
    Parameters:
    - targets_string: Comma-separated target list or 'all'
    
    Returns: Array of valid target names
    """
    UI.user_error! 'A target must be specified, for example: LekaApp, LekaUpdater, etc.' if targets_string.nil?
    
    available_targets = RELEASE_BUNDLE_IDS.map { |app| File.extname(app.to_s).delete('.') }
    
    if targets_string == 'all'
      available_targets
    else
      targets = targets_string.split(',').map(&:strip)
      invalid_targets = targets - available_targets
      
      unless invalid_targets.empty?
        UI.user_error! "Invalid targets: #{invalid_targets.join(', ')}. Available targets: #{available_targets.join(', ')}"
      end
      
      targets
    end
  end

  # MARK: - Utility Lanes
  # MARK: - Utility Lanes
  
  desc "Test lane to verify fastlane configuration is working correctly"
  desc "Usage: fastlane helloworld"
  desc "This lane performs a basic connectivity test and displays configuration information"
  lane :helloworld do
    UI.important "Hello, Fastlane! (from #{Dir.pwd}, root: #{ROOT_DIR})"
  end

  # MARK: - Certificate Management Lanes

  desc "Synchronize certificates and provisioning profiles from the certificates repository"
  desc "This lane downloads existing certificates without creating new ones"
  desc "Options:"
  desc " - release: [Boolean] If true, also syncs App Store certificates (default: false)"
  desc "Usage: fastlane sync_certificates release:true"
  desc "Note: Requires MATCH_PASSWORD and MATCH_GIT_BASIC_AUTHORIZATION environment variables"
  lane :sync_certificates do |options|
    UI.important 'Delete local provisioning profiles'

    # Use helper function for keychain setup
    setup_keychain

    # Sync development certificates for all Leka apps
    match(
      type: 'development',
      app_identifier: DEVELOPMENT_WILDCARD_BUNDLE_ID,
      readonly: true,                # Don't create new certificates
      keychain_name: 'io.leka.fastlane.keychain'
    )

    # Optionally sync App Store certificates for production releases
    if options[:release]
      match(
        type: 'appstore',
        app_identifier: RELEASE_BUNDLE_IDS,
        readonly: true,
        keychain_name: 'io.leka.fastlane.keychain'
      )
    end
  end

  desc "Create new certificates and provisioning profiles"
  desc "This lane generates new certificates when needed (e.g., for new devices)"
  desc "Options:"
  desc " - release: [Boolean] If true, also creates App Store certificates (default: false)"
  desc "Usage: fastlane create_certificates release:true"
  desc "Note: Use with caution as this can invalidate existing certificates"
  lane :create_certificates do |options|
    # Use helper function for keychain setup
    setup_keychain

    # Force creation of development certificates for new devices
    match(
      type: 'development',
      app_identifier: DEVELOPMENT_WILDCARD_BUNDLE_ID,
      force_for_new_devices: true,   # Create new profiles if devices were added
      keychain_name: 'io.leka.fastlane.keychain'
    )

    # Optionally create App Store certificates
    if options[:release]
      match(
        type: 'appstore',
        app_identifier: RELEASE_BUNDLE_IDS,
        keychain_name: 'io.leka.fastlane.keychain'
      )
    end
  end

  # MARK: - Release Lanes

  desc "Build and submit internal beta versions to TestFlight"
  desc "This lane builds apps in beta configuration and uploads them to TestFlight for internal testing"
  desc ""
  desc "Process Overview:"
  desc "1. Validates target parameter and sets up build configuration"
  desc "2. Generates Xcode project using Tuist with beta settings"
  desc "3. Configures App Store Connect API authentication"
  desc "4. Determines build number using commit SHA encoding system"
  desc "5. Builds the app with App Store export method"
  desc "6. Uploads to TestFlight with changelog"
  desc "7. Cleans up temporary keychain"
  desc ""
  desc "Build Number System:"
  desc "Build numbers follow the format 'MAJOR.COMMIT_SHA_DECIMAL' where:"
  desc "- MAJOR: Incremented for each build (starts from latest TestFlight build + 1)"
  desc "- COMMIT_SHA_DECIMAL: First 10 hex chars of commit SHA converted to decimal"
  desc "This allows tracking which commit each build came from"
  desc ""
  desc "Options:"
  desc " - targets: [String] Comma-separated list of targets to build, or 'all' for all targets"
  desc "           Available targets: LekaApp, LekaUpdater"
  desc "           Example: 'LekaApp,LekaUpdater' or 'all'"
  desc ""
  desc "Environment Variables Required:"
  desc " - APP_STORE_CONNECT_API_KEY_ID: API key ID for TestFlight uploads"
  desc " - APP_STORE_CONNECT_ISSUER_ID: Issuer ID for App Store Connect API"  
  desc " - APP_STORE_CONNECT_API_KEY_CONTENT: Private key content for API"
  desc " - FASTLANE_KEYCHAIN_PASSWORD: Password for temporary keychain"
  desc " - MATCH_PASSWORD: Password for certificates repository"
  desc " - MATCH_GIT_BASIC_AUTHORIZATION: Auth token for certificates repo"
  desc ""
  desc "Usage Examples:"
  desc " fastlane beta_internal targets:LekaApp"
  desc " fastlane beta_internal targets:LekaApp,LekaUpdater" 
  desc " fastlane beta_internal targets:all"
  desc ""
  desc "Note: This lane is typically triggered by GitHub Actions on PR labels or develop branch pushes"
  lane :beta_internal do |options|
    # Validate environment and parameters
    validate_build_environment
    apps = validate_targets(options[:targets])

    UI.header 'Step: Set targets to build'
    UI.important "The following targets will be built: #{apps}"

    # Process each app individually
    apps.each do |app|
      # Beta apps use .beta suffix to distinguish from production releases
      app_bundle_id = "io.leka.apf.app.#{app}.beta"
      app_xcodeproj = "#{ROOT_DIR}/Apps/#{app}/#{app}.xcodeproj"

      UI.header "Step: Generate, build & upload target: #{app} / #{app_bundle_id} / #{app_xcodeproj}"

      # MARK: - Tuist Project Generation
      # Generate Xcode project using Tuist with beta-specific configuration
      Dir.chdir('..') do
        # Configure Tuist for beta builds using helper function
        configure_tuist_environment(
          build_type: 'beta',
          app_bundle_id: app_bundle_id
        )
        
        # Generate project without opening Xcode and without binary cache for clean builds
        system('tuist', 'generate', '--no-open', '--no-binary-cache', app.to_s)
      end

      begin
        # MARK: - CI Environment Setup
        # Use helper function for App Store Connect authentication
        setup_app_store_connect_auth(auth_type: 'beta')

        # MARK: - Pull Request Information
        # Use helper function to determine PR number for changelog context
        pr_number = detect_pr_number

        # MARK: - Version and Build Number Management
        UI.header 'Step: Create verson and new build number'

        # Get current version from Xcode project (e.g., "1.2.3")
        version_number = get_version_number(xcodeproj: app_xcodeproj.to_s)
        
        # Get the latest build number from TestFlight for this version
        # This is used as base for incrementing to the next build number
        latest_build_number = latest_testflight_build_number(
          app_identifier: app_bundle_id.to_s,
          version: version_number
        ).to_s
        
        # Generate new build number using commit SHA encoding
        # See create_new_build_number lane for detailed explanation
        new_build_number = create_new_build_number(latest_build_number: latest_build_number)
        
        # Create date stamp for IPA filename
        build_date = Time.new.strftime('%Y_%m_%d')

        UI.important "Next release for: #{app_bundle_id}"
        UI.important "Version number: #{version_number}"
        UI.important "Build number: #{new_build_number}"

        # MARK: - Changelog Generation
        # Generate changelog for TestFlight description
        # This includes git log between commits with proper formatting
        testflight_changelog = generate_changelogs(
          release_type: 'beta',                    # Indicates this is a beta release
          target: app,                             # App name for changelog
          version_number: version_number,          # Version for display
          latest_build_number: latest_build_number, # Previous build for comparison
          new_build_number: new_build_number,      # New build number
          pr_number: pr_number                     # PR context for changelog
        )

        UI.message testflight_changelog

        # MARK: - Build Configuration
        # Update build number in Xcode project
        increment_build_number(
          build_number: new_build_number,
          xcodeproj: app_xcodeproj.to_s
        )

        # Build the app with App Store distribution
        build_app(
          export_method: 'app-store',              # Required for TestFlight
          export_options: {
            provisioningProfiles: {
              # Use match-generated provisioning profile
              app_bundle_id.to_s => "match AppStore #{app_bundle_id}"
            }
          },
          workspace: 'ios-monorepo.xcworkspace',   # Generated by Tuist
          scheme: app,                             # App target scheme
          output_directory: './.build',            # Build output directory
          # IPA filename includes date, app name, version for easy identification
          output_name: "#{build_date}-#{app}-beta-v#{version_number}-#{new_build_number}"
        )

        # MARK: - TestFlight Upload
        # Upload the built IPA to TestFlight
        upload_to_testflight(
          app_identifier: app_bundle_id.to_s,
          ipa: "./.build/#{build_date}-#{app}-beta-v#{version_number}-#{new_build_number}.ipa",
          skip_waiting_for_build_processing: true, # Don't wait for Apple processing
          distribute_external: false,              # Internal testing only
          groups: %w[LekaTeam],                    # TestFlight testing group
          changelog: testflight_changelog          # Generated changelog
        )
      ensure
        # MARK: - Cleanup
        # Use helper function to clean up the temporary keychain
        cleanup_keychain
      end
    end
  end

  desc "Build and release production versions to the App Store"
  desc "This lane builds apps in production configuration and submits them to App Store Connect"
  desc ""
  desc "Process Overview:"
  desc "1. Validates single target parameter (only one app can be released at a time)"
  desc "2. Generates Xcode project using Tuist with production settings"
  desc "3. Configures App Store Connect API with release-specific credentials"
  desc "4. Determines build number and generates comprehensive changelog"
  desc "5. Builds the app with App Store export method"
  desc "6. Uploads to App Store Connect with metadata and screenshots"
  desc "7. Submits for review with automatic release configuration"
  desc "8. Cleans up temporary keychain"
  desc ""
  desc "Key Differences from beta_internal:"
  desc "- Uses production bundle IDs (without .beta suffix)"
  desc "- Uses separate API credentials for enhanced security"
  desc "- Includes metadata and screenshot uploads"
  desc "- Submits directly for App Store review"
  desc "- Configured for automatic release after approval"
  desc ""
  desc "Options:"
  desc " - target: [String] Single target to release (required)"
  desc "           Available targets: LekaApp, LekaUpdater"
  desc "           Example: 'LekaApp' (only one target allowed)"
  desc ""
  desc "Environment Variables Required:"
  desc " - APP_STORE_CONNECT_API_KEY_ID_RELEASE_APP_STORE: Separate API key for releases"
  desc " - APP_STORE_CONNECT_ISSUER_ID: Issuer ID for App Store Connect API"
  desc " - APP_STORE_CONNECT_API_KEY_CONTENT_RELEASE_APP_STORE: Release-specific private key"
  desc " - FASTLANE_KEYCHAIN_PASSWORD: Password for temporary keychain"
  desc " - MATCH_PASSWORD: Password for certificates repository"
  desc " - MATCH_GIT_BASIC_AUTHORIZATION: Auth token for certificates repo"
  desc ""
  desc "Usage Examples:"
  desc " fastlane release target:LekaApp"
  desc " fastlane release target:LekaUpdater"
  desc ""
  desc "Note: This lane is typically triggered by GitHub Actions on specific PR labels"
  desc "      Only one app can be released at a time for better control and review"
  lane :release do |options|
    # Validate environment and parameters
    validate_build_environment
    
    # Validate and get single target for release
    UI.user_error! 'A target must be specified, for example: LekaApp, LekaUpdater, etc.' if options[:target].nil?
    UI.user_error! 'Only one app can be released at a time' if options[:target].split(',').count > 1

    targets = validate_targets(options[:target])
    app = targets.first

    UI.header 'Step: Set target to build'
    UI.important "The following target will be built: #{app}"

    # Production apps use the base bundle ID (no .beta suffix)
    app_bundle_id = "io.leka.apf.app.#{app}"
    app_xcodeproj = "#{ROOT_DIR}/Apps/#{app}/#{app}.xcodeproj"

    UI.header "Step: Generate, build & upload target: #{app} / #{app_bundle_id} / #{app_xcodeproj}"

    # MARK: - Tuist Project Generation for Production
    Dir.chdir('..') do
      # Configure Tuist for production builds using helper function
      configure_tuist_environment(
        build_type: 'release',
        app_bundle_id: app_bundle_id
      )
      
      system('tuist', 'generate', '--no-open', '--no-binary-cache', app.to_s)
    end

    begin
      # MARK: - CI Environment Setup (Production)
      # Use helper function for App Store Connect authentication (release credentials)
      setup_app_store_connect_auth(auth_type: 'release')

      # Get PR number using helper function (same logic as beta_internal)
      pr_number = detect_pr_number

      # MARK: - Version and Build Number Management (Production)
      UI.header 'Step: Create verson and new build number'

      version_number = get_version_number(xcodeproj: app_xcodeproj.to_s)
      latest_build_number = latest_testflight_build_number(
        app_identifier: app_bundle_id.to_s,      # Note: production bundle ID
        version: version_number
      ).to_s
      new_build_number = create_new_build_number(latest_build_number: latest_build_number)
      build_date = Time.new.strftime('%Y_%m_%d')

      UI.important "Next release for: #{app_bundle_id}"
      UI.important "Version number: #{version_number}"
      UI.important "Build number: #{new_build_number}"
      UI.important "Metadata path: #{ROOT_DIR}/fastlane/release/#{app}/metadata"

      # capture_screenshots # ? not working yet - TODO: investigate screenshot automation

      # Generate changelog for release (includes GitHub and Slack variants)
      generate_changelogs(
        release_type: 'release',                 # Indicates production release
        target: app,
        version_number: version_number,
        latest_build_number: latest_build_number,
        new_build_number: new_build_number,
        pr_number: pr_number
      )

      # Update build number and build the app (same as beta)
      increment_build_number(
        build_number: new_build_number,
        xcodeproj: app_xcodeproj.to_s
      )

      build_app(
        export_method: 'app-store',
        export_options: {
          provisioningProfiles: {
            app_bundle_id.to_s => "match AppStore #{app_bundle_id}"
          }
        },
        workspace: 'ios-monorepo.xcworkspace',
        scheme: app,
        output_directory: './.build',
        # Note: 'release' in filename instead of 'beta'
        output_name: "#{build_date}-#{app}-release-v#{version_number}-#{new_build_number}"
      )

      # MARK: - App Store Submission with Full Metadata
      # This uploads the app with complete App Store metadata and submits for review
      upload_to_app_store(
        force: true,                             # Force upload even if warnings
        app_identifier: app_bundle_id.to_s,
        ipa: "./.build/#{build_date}-#{app}-release-v#{version_number}-#{new_build_number}.ipa",
        metadata_path: "#{ROOT_DIR}/fastlane/release/#{app}/metadata",      # App Store descriptions, keywords, etc.
        screenshots_path: "#{ROOT_DIR}/fastlane/release/#{app}/screenshots", # App Store screenshots
        reject_if_possible: true,                # Reject existing build if in review
        submit_for_review: true,                 # Automatically submit for Apple review
        automatic_release: true,                 # Release automatically after approval
        app_rating_config_path: "#{ROOT_DIR}/fastlane/release/#{app}/metadata/app_rating_config.json",
        
        # App Store Review submission information
        submission_information: {
          export_compliance_uses_encryption: false,        # No encryption export restrictions
          add_id_info_uses_idfa: false,                   # No advertising identifier usage
          content_rights_contains_third_party_content: true,  # Contains third-party content
          content_rights_has_rights: true                 # We have rights to the content
        },
        
        # Run precheck validations before submission
        run_precheck_before_submit: true,
        precheck_include_in_app_purchases: false         # No in-app purchases to validate
      )
    ensure
      # MARK: - Cleanup (same as beta_internal)
      cleanup_keychain
    end
  end

  # MARK: - Changelog and Utility Lanes

  desc "Generate changelogs for TestFlight, GitHub, and Slack notifications"
  desc "This lane creates formatted changelogs by analyzing git commit history between builds"
  desc ""
  desc "Changelog System Overview:"
  desc "The system generates three different changelog formats:"
  desc "1. TestFlight: Plain text for app submission notes (no emojis/markdown)"
  desc "2. GitHub: Markdown formatted for PR comments and releases"
  desc "3. Slack: Slack-formatted with emojis for team notifications"
  desc ""
  desc "Git History Analysis:"
  desc "- For PR builds: Compares HEAD commit to base branch (usually develop)"
  desc "- For direct pushes: Compares to previous TestFlight build commit"
  desc "- Uses git_log_to_notes.py script to format commit messages"
  desc "- Handles edge cases like force pushes and missing commits"
  desc ""
  desc "Options (all required):"
  desc " - release_type: [String] 'beta' or 'release' to determine formatting"
  desc " - target: [String] App name for display in changelog"
  desc " - version_number: [String] App version number"
  desc " - latest_build_number: [String] Previous build for comparison"
  desc " - new_build_number: [String] New build number"
  desc " - pr_number: [String] PR number or 'NO_PR' for direct pushes"
  desc ""
  desc "Returns: TestFlight changelog text"
  desc "Side Effects: In CI, writes all three changelog formats to GITHUB_ENV"
  desc ""
  desc "Usage: This lane is called internally by beta_internal and release lanes"
  lane :generate_changelogs do |options|
    UI.important options

    release_type = options[:release_type]
    app_name = options[:target].to_s
    version_number = options[:version_number].to_s
    latest_build_number = options[:latest_build_number].to_s
    new_build_number = options[:new_build_number].to_s

    pr_number = options[:pr_number].to_s

    test_flight_commit_sha = build_number_to_commit_sha(build_number: latest_build_number)
    head_commit_sha = build_number_to_commit_sha(build_number: new_build_number)

    base_commit_sha = pr_number == 'NO_PR' ? test_flight_commit_sha.to_s : GIT_BASE_REF

    UI.message "head_commit_sha:        #{head_commit_sha}"
    UI.message "base_commit_sha:        #{base_commit_sha}"
    UI.message "test_flight_commit_sha: #{test_flight_commit_sha}"

    git_log_to_notes_script = "#{ROOT_DIR}/Tools/Scripts/git_log_to_notes.py"

    git_log_with_emojis, stderr_git_log_with_emojis, status_git_log_with_emojis = Open3.capture3(
      'python3',
      git_log_to_notes_script,
      '-f', base_commit_sha.to_s,
      '-l', head_commit_sha.to_s
    )

    git_log_no_emojis, stderr_git_log_no_emojis, status_git_log_no_emojis = Open3.capture3(
      'python3',
      git_log_to_notes_script,
      '-r',
      '-f', base_commit_sha.to_s,
      '-l', head_commit_sha.to_s
    )

    if status_git_log_with_emojis.success? && status_git_log_no_emojis.success?
      UI.success 'Logs generated successfully'
    else
      UI.error 'Could not fetch the changes and generate the logs'
      UI.error stderr_git_log_with_emojis.rstrip
      UI.error stderr_git_log_no_emojis.rstrip
    end

    git_log_for_slack = if git_log_with_emojis.rstrip.empty?
                          '_Could not fetch the changes... Commits may have been overwritten by force push._'
                        else
                          git_log_with_emojis.rstrip
                        end

    git_log_for_github = if git_log_with_emojis.rstrip.empty?
                           '*Could not fetch the changes... Commits may have been overwritten by force push.*'
                         else
                           git_log_with_emojis.rstrip
                         end

    git_log_for_test_flight = if git_log_no_emojis.rstrip.empty?
                                'Could not fetch the changes... Commits may have been overwritten by force push.'
                              else
                                git_log_no_emojis.rstrip
                              end

    UI.message 'Creating CHANGELOG_FOR_SLACK'

    changelog_for_slack = <<~EOF_CHANGELOG_FOR_SLACK
      #{release_type == 'beta' ? ":test_tube: *New TestFlight Build - #{app_name}* :airplane:" : ":bookmark: *New AppStore Release - #{app_name}* :rocket:"}

      New version of #{app_name} is available for testing on TestFlight. Please check the changelog and install the app on your device. :rocket:

      *App*: `#{app_name}`
      *Version*: `#{version_number}`
      *Build*: `#{new_build_number}`
      *Commit*: `#{head_commit_sha}` - https://github.com/leka/ios-monorepo/commit/#{head_commit_sha}
      *PR*: #{pr_number == 'NO_PR' ? 'n/a' : "https://github.com/leka/ios-monorepo/pull/#{pr_number}"}

      *Changes compared to #{pr_number == 'NO_PR' ? "latest TestFlight build `#{latest_build_number}`" : "`#{GIT_BASE_REF}` / `#{head_commit_sha}`"}*:

      ```
      python3 ./Tools/Scripts/git_log_to_notes.py -f #{base_commit_sha} -l #{head_commit_sha}
      ```

      #{git_log_for_slack}
    EOF_CHANGELOG_FOR_SLACK

    UI.message "CHANGELOG_FOR_SLACK:\n#{changelog_for_slack}"

    UI.message 'Creating CHANGELOG_FOR_GITHUB'

    changelog_for_github = <<~EOF_CHANGELOG_FOR_GITHUB
      #{release_type == 'beta' ? "## :test_tube: New TestFlight Build - #{app_name} :airplane:" : "## :bookmark: New AppStore Release - #{app_name} :rocket:"}

      New version of #{app_name} is available for testing. Please check the changelog and install the app on your device. :rocket:

      **App**: #{app_name}
      **Version**: `#{version_number}`
      **Build**: `#{new_build_number}`
      **Commit**: #{head_commit_sha}
      **PR**: #{pr_number == 'NO_PR' ? 'n/a' : "https://github.com/leka/ios-monorepo/pull/#{pr_number}"}

      ## Changes compared to #{pr_number == 'NO_PR' ? "latest TestFlight build `#{latest_build_number}`" : "`#{GIT_BASE_REF}` / #{head_commit_sha}"}

      ```shell
      python3 ./Tools/Scripts/git_log_to_notes.py -f #{base_commit_sha} -l #{head_commit_sha}
      ```

      #{git_log_for_github}
    EOF_CHANGELOG_FOR_GITHUB

    UI.message "CHANGELOG_FOR_GITHUB:\n#{changelog_for_github}"

    UI.message 'Creating CHANGELOG_FOR_TEST_FLIGHT'

    changelog_for_test_flight = <<~EOF_CHANGELOG_FOR_TEST_FLIGHT
      Version: #{version_number}
      Build: #{new_build_number}
      Commit: #{head_commit_sha} - https://github.com/leka/ios-monorepo/commit/#{head_commit_sha}
      PR: #{pr_number == 'NO_PR' ? 'n/a' : "https://github.com/leka/ios-monorepo/pull/#{pr_number}"}

      Changes compared to #{pr_number == 'NO_PR' ? "latest TestFlight build `#{latest_build_number}`" : "#{GIT_BASE_REF} / #{head_commit_sha}"}:

      #{git_log_for_test_flight}
    EOF_CHANGELOG_FOR_TEST_FLIGHT

    UI.message "CHANGELOG_FOR_TEST_FLIGHT:\n#{changelog_for_test_flight}"

    if ENV['CI']
      UI.message 'Writing changelogs to GITHUB_ENV'
      File.write(
        ENV.fetch('GITHUB_ENV', nil).to_s,
        "CHANGELOG_FOR_SLACK<<EOF_CHANGELOG_FOR_SLACK\n" \
        "#{changelog_for_slack}\n" \
        "EOF_CHANGELOG_FOR_SLACK\n\n",
        mode: 'a'
      )
      File.write(
        ENV.fetch('GITHUB_ENV', nil).to_s,
        "CHANGELOG_FOR_GITHUB<<EOF_CHANGELOG_FOR_GITHUB\n" \
        "#{changelog_for_github}\n" \
        "EOF_CHANGELOG_FOR_GITHUB\n\n",
        mode: 'a'
      )
      File.write(
        ENV.fetch('GITHUB_ENV', nil).to_s,
        "CHANGELOG_FOR_TEST_FLIGHT<<EOF_CHANGELOG_FOR_TEST_FLIGHT\n" \
        "#{changelog_for_test_flight}\n" \
        "EOF_CHANGELOG_FOR_TEST_FLIGHT\n\n",
        mode: 'a'
      )
    end

    changelog_for_test_flight
  end

  # MARK: - Build Number Management System
  #
  # The Leka iOS project uses a unique build number system that encodes commit SHA 
  # information directly into the build number. This allows tracking exactly which
  # commit each build came from, which is crucial for debugging and rollbacks.
  #
  # Build Number Format: "MAJOR.COMMIT_SHA_DECIMAL"
  # - MAJOR: Sequential number starting from 1, incremented for each build
  # - COMMIT_SHA_DECIMAL: First 10 hex characters of commit SHA converted to decimal
  #
  # Example:
  # - Commit SHA: a1b2c3d4e5f6789...
  # - Short hash: a1b2c3d4e5 (first 10 hex chars)
  # - Decimal: 694847286757 (hex to decimal conversion)
  # - Build number: 123.694847286757
  #
  # Benefits:
  # - Bidirectional conversion between build numbers and commit SHAs
  # - Each build number uniquely identifies its source commit
  # - Supports rollbacks and debugging by commit reference
  # - Maintains compatibility with App Store build number requirements

  desc "Convert commit SHA to decimal for build number encoding"
  desc "Takes a full 40-character commit SHA and converts the first 10 hex characters"
  desc "to decimal representation for use in build numbers."
  desc ""
  desc "Process:"
  desc "1. Extract first 10 hex characters from commit SHA"
  desc "2. Convert hex to decimal"
  desc "3. Validate decimal fits within build number constraints"
  desc "4. Verify round-trip conversion works correctly"
  desc ""
  desc "Options:"
  desc " - long_hash: [String] Full 40-character commit SHA (required)"
  desc ""
  desc "Returns: Decimal string representation of commit SHA"
  desc "Example: commit_sha_to_decimal(long_hash: 'a1b2c3d4e5f6789...')"
  lane :commit_sha_to_decimal do |options|
    # Validate input parameter
    UI.user_error! 'A long_hash must be specified' if options[:long_hash].nil?

    long_hash = options[:long_hash].to_s

    # Validate commit SHA length (must be full 40-character hash)
    UI.crash! 'Commit hash must be 40 characters' if long_hash.length < 40

    # Extract first 10 hex characters and convert to decimal
    short_hash = long_hash.slice(0, 10)
    short_hash_decimal = short_hash.to_i(16).to_s

    UI.message "Long hash:        #{long_hash}"
    UI.message "Short hash:       #{short_hash}"
    UI.message "Short hash (dec): #{short_hash_decimal}"

    # Validate decimal representation fits in build number constraints
    # App Store has specific limits on build number length
    UI.crash! 'Short hash dec must be shorter than 13 characters' if short_hash_decimal.length > 13

    # Verify round-trip conversion works (quality assurance)
    control_hash = build_number_to_commit_sha(build_number: "1234.#{short_hash_decimal}")
    UI.crash! 'Short hash and control hash are NOT equal' unless control_hash.to_s == short_hash.to_s

    UI.success "Short hash (dec): #{short_hash_decimal}"
    short_hash_decimal
  end

  desc "Convert decimal build number component back to commit SHA"
  desc "Reverse operation of commit_sha_to_decimal - extracts commit SHA from build number"
  desc ""
  desc "Process:"
  desc "1. Parse decimal component from build number (after the dot)"
  desc "2. Convert decimal back to hexadecimal"
  desc "3. Pad with leading zeros to get 10-character hash"
  desc "4. Validate result meets constraints"
  desc ""
  desc "Options:"
  desc " - build_number: [String] Build number in format 'MAJOR.DECIMAL' (required)"
  desc ""
  desc "Returns: 10-character hex string representing commit SHA prefix"
  desc "Example: build_number_to_commit_sha(build_number: '123.694847286757')"
  lane :build_number_to_commit_sha do |options|
    # Validate input parameter
    UI.user_error! 'A build number must be specified' if options[:build_number].nil?

    build_number = options[:build_number].to_s

    # Extract decimal component (everything after the last dot)
    short_hash_decimal = build_number.split('.').last

    # Validate decimal component length
    UI.crash! 'Short hash dec must be shorter than 13 characters' if short_hash_decimal.length > 13

    # Convert decimal back to hexadecimal and pad to 10 characters
    short_hash = short_hash_decimal.to_i.to_s(16).rjust(10, '0')

    # Validate hex result length
    UI.crash! 'Short hash must be shorter than 10 characters' if short_hash.length > 11

    UI.success "Short hash (hex): #{short_hash}"
    short_hash
  end

  desc "Generate new build number for the current commit"
  desc "Creates a new build number by incrementing the major version and encoding the current commit SHA"
  desc ""
  desc "Process:"
  desc "1. Parse latest build number to get major version"
  desc "2. Increment major version by 1"
  desc "3. Get current commit SHA from git"
  desc "4. Convert commit SHA to decimal using commit_sha_to_decimal"
  desc "5. Combine major version and decimal SHA: 'MAJOR.SHA_DECIMAL'"
  desc "6. Validate final build number meets App Store constraints"
  desc ""
  desc "Options:"
  desc " - latest_build_number: [String] Previous build number for increment base (required)"
  desc ""
  desc "Returns: New build number string in format 'MAJOR.SHA_DECIMAL'"
  desc "Example: create_new_build_number(latest_build_number: '122.694847286757')"
  desc "         might return '123.845739204821' for current commit"
  lane :create_new_build_number do |options|
    # Validate input parameter
    UI.user_error! 'A build number must be specified' if options[:latest_build_number].nil?

    latest_build_number = options[:latest_build_number].to_s

    # Increment major version (first part before the dot)
    new_build_number_major = latest_build_number.split('.').first.to_i + 1

    # Get current commit SHA from git
    last_commit_sha = last_git_commit[:commit_hash]

    # Convert current commit SHA to decimal representation
    short_commit_sha_dec = commit_sha_to_decimal(long_hash: last_commit_sha)

    # Combine major version and SHA decimal
    new_build_number = "#{new_build_number_major}.#{short_commit_sha_dec}"

    # Validate final build number meets App Store constraints (max 18 characters)
    UI.crash! 'Build number must be 18 characters max' if new_build_number.length > 18

    UI.success "New build number: #{new_build_number}"
    new_build_number
  end
end
